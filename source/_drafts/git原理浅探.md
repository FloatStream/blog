---
title: git原理浅探
tags:
  - git
  - 笔记
categories: Git
cover: images/Git.png
---

Git 可谓是风靡全球的版本管理软件, 深受众多程序员的喜爱, 不知市面上有多少讲解 Git 的课程和视频, 而正是这样一款受众如此广泛的软件, 它的一些用法却令许多人疑惑; 正是抱着这样的疑惑, 我向它的"底层"走去, 而这里也确实给出了问题的答案

<!-- more -->

# 问题初现

在 Git 的学习过程之中, 我们总会接触到 `remote repo`, `local repo`, `index(staged)`, `work tree` 的概念, 正常的流程便是

```
Work Tree
	some files                                  编辑文件
-----------------------------------------------------↓|add|-------------
Index
	next commit object                          存入暂存区
-----------------------------------------------------↓|commit|----------
Local Repo
	HEAD -> commit object                       存入本地仓库
-----------------------------------------------------↓|push|------------
Remote Repo
	HEAD(Remote)-> commit object(Remote）     远程仓库同步本地仓库
```

但在开发项目的过程中, 难免有各种各样的回退、撤销...... 而这也便是使用 Git 等版本管理软件的最核心目的, 而很遗憾的是, 作为一款风靡全球, 让无数程序员又爱又恨的版本管理软件, 它的回退、撤销指令却有些混乱, 而这也是很多程序员对它"恨"的根本原因

在经过一段时间的学习探索以后 (由其是对与 Git 原理的粗浅探究), 让我对 `reset`和 `checkout` 这两个指令的奇怪之处有了一点自己的看法, 并为国内许多教程错误的教授方式而感到惋惜, 因为从底层原理的角度来看这两个指令的奇怪之处并不奇怪, 只是单纯的从最终效果的角度来看, 两指令的奇怪之处——"大相径庭且毫无规律"的子命令格式——便无法解释

在 Git 的底层中, 各个过程、对象的关系更像下图; 所以要解释撤销回退命令的奇怪之处, 首先需要了解的便是 Git 的基本运行原理

![img](git%E5%8E%9F%E7%90%86%E6%B5%85%E6%8E%A2/%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%86%E5%9B%BE.jpg)

# 基本原理

## 文件存储/管理原理

Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。

![delta](git%E5%8E%9F%E7%90%86%E6%B5%85%E6%8E%A2/%E5%B7%AE%E5%BC%82%E7%AE%A1%E7%90%86.jpg)

Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个**快照流**。

![fast](git%E5%8E%9F%E7%90%86%E6%B5%85%E6%8E%A2/%E5%BF%AB%E7%85%A7%E6%B5%81.jpg)

在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象

为了更形象地说明, 现假设有一个工作目录, 其中有三个文件, 在 `git add` 过程中会为每个文件计算校验和, 并把当前版本的快照保存到 Git 仓库中 (*Git 使用 **blob 对象**来保存它们*), 最终将校验和保存到暂存区域等待提交; 而在 `git commit` 过程中 Git 会先计算每个子目录的校验和, 然后在 Git 仓库中将这些校验和保存为**树对象**, 之后便会创建一个 **commit 对象**, 它除了包含上面提到的那些信息外, 还包含了指向这个树对象的指针。如此便可以在需要的时候恢复此版本的文件, 具体对象关系如下

![f5a2b93b19e024d1158ceec8838515c](git%E5%8E%9F%E7%90%86%E6%B5%85%E6%8E%A2/f5a2b93b19e024d1158ceec8838515c.jpg)

## 分支原理

Git 的分支, 其实本质上仅仅是一个指向提交对象的可变指针, 而这也是一切**"魔法"**的根源, `reset` 和 `checkout` 之谜的谜底也正是由于 Git 特殊的分支机制

除去分支指针以外, Git 还有一个特殊的**HEAD**指针, 用于指向当前所处分支, 而可以在不同分支间切换也是因为该指针的存在, 具体情况如下

![241582c1a94fcbef8f766abe74a431e](git%E5%8E%9F%E7%90%86%E6%B5%85%E6%8E%A2/241582c1a94fcbef8f766abe74a431e.jpg)

# 解密

为方便下文叙述方便及准确, 现先明确一些名词与其所对应的概念

- **暂存指针**: 暂存区本质上保存的便是下一次提交的数据快照索引集, 而 `commit` 命令生成的**树对象**和**提交对象**便依此而生成, 所以我将暂存区抽象为**指向本分支下一次提交对象的一个指针**, 暂且称之为**暂存指针**将 (暂存区的英文本身就是**Index**, 索引之意, 本身便包含指针的意思, 而国内通常翻译为暂存区, 实是又一例翻译疏漏之处, 无奈依众人之意而称之)
- **本地仓库指针**: 即**HEAD**指针, 通常**HEAD指针**并不指向具体提交对象, 而是**指向分支指针, 间接指向提交对象**
- **分支指针**: 即指向逻辑上某分支最后一次提交对象的指针

## reset 命令

`git reset` 命令的完整形式应该是:

```
git reset [options] <mode> <commit> <pathspec>
```

本身提供的服务是重置当前**分支指针**[^1] 到指定状态, 实现重置的效果; 我将该命令分成四部分 `选项`, `模式`, `依赖提交`, `重置路径`

- 选项 (options): 指定 reset 输入输出或获取参数的部分, 相当于配置 reset 以获得不同的表现
- **模式 (mode)**: reset 命令的核心, 决定重置的范围大小 (即需要调整哪些指针) 以及一些特定行为, 此处只讨论 `mixed`, `hard`, `soft`三种模式, 主要是对于重置范围大小 (指`本地仓库, 暂存区, 工作区`层面的大小) 的区别
  - `mixed`: 重置**本地仓库**和**暂存区**
  - `soft`: 重置**本地仓库**
  - `hard`: 重置**本地仓库, 暂存区和工作区**
- **依赖提交 (commit)**: 指定 reset 命令依据哪个提交对象来重置选定范围的数据, 默认为**HEAD**指针指向的提交对象
- **重置路径 (pathspec)**: 指定 reset 命令需要重置的具体文件路径, 默认为**无**也即整个提交, 若指定则会发生一些**魔法**

> **重置路径的魔法**
>
> 对于本地仓库来说, 此时只存在一个指针指向当前提交对象, 无法改变当前提交对象, 在指定重置路径时, 本地仓库层面的指针无法移动, 因为不存在一个**重置路径文件恢复, 其它路径文件却不恢复**的提交对象, 因此本地仓库不重置, 仍指向原提交对象
>
> **注:** 在 `pathspec` 参数中有个特殊的路径, 即 `.`, 代表工作目录的所有文件; 如果给定此参数, 则 reset 仍会认为给出了 `pathspec` 参数, 效果上会重置该 `mode` 下除**本地仓库**外区域的所有文件, 和重置为某个 **commit** 的效果类似, 除了**本地仓库**层面仍会指向当前提交外

在了解了该命令的完整形式与各参数的意义与特殊规则, 我们便可以解释在各个教程中的 reset 指令的奇怪之处 (接下来的部分我会写出普通使用教程提供的指令写法, 并从原理角度解释该指令的由来)

**例**:

1. 撤销暂存区提交 | 撤销暂存区部分文件提交 (即`撤销 git add <.|files> 效果`)

   ```
   指令: git reset {空 | [--] files}
   完整形式: git reset --mixed HEAD | git reset --mixed HEAD [--] files
   ```

   如果你看懂了上面的原理解释, 可能便能看懂为什么这条指令可以达到撤销 `git add` 的效果, 原因便是依据**HEAD**指针指向的提交对象 (即上一次提交的对象) 重置**本地仓库**和**暂存区**, 因为**本地仓库**的指针就是**HEAD**, 所以**本地仓库**指向对象不会改变, 而且**暂存指针**会指向上一次提交对象, 因此从结果来看便是撤销了 `git add` 的暂存记录; 撤销指定文件的暂存记录, 本地仓库不修改的原因除了 `依赖提交` 就是**HEAD指向的对象**以外, 还因为提供了 `重置路径` 导致**HEAD指针本身就不能动**, 在 `soft` 模式下, reset 命令不接受 `重置路径` 参数 (**另因为在`hard`模式下使用 `重置路径` 会导致逻辑混乱, 因此在`hard`模式下也不允许使用该参数**)

2. 撤销工作区修改 | 撤销工作区部分文件修改 (即`撤销 修改文件 效果`)

   ```
   指令: git reset --hard
   完整形式: git reset --hard HEAD
   ```

   **该指令只有在暂存区无暂存记录时, 才可达到此效果, 否则会将暂存区记录一并撤销**
   原理基本如上一条指令, 在 `hard` 模式下 reset 重置**本地仓库, 暂存区和工作区**, 又因为暂存区无记录, 因此最后实现了该效果

3. 回退至之前版本

   ```
   a.
   	指令: git reset --soft <commit>(HEAD^|HEAD~n|某提交的16进制校验和)
   	完整形式: 如上
   b.
   	指令: git reset {<commit> | <commit> [--] files}
   	完整形式: git reset --mixed {<commit> | <commit> [--] files}
   c.
   	指令: git reset --hard <commit>
   	完整形式: 如上
   ```

   **a.** 本地仓库回退至指定版本

   **b.** 本地仓库和暂存区回退至指定版本; 若指定**重置路径**, 则只有暂存区指定路径的文件或目录回退至指定版本, 本地仓库不变

   **c.** 本地仓库, 暂存区和工作区回退至指定版本

以上便是 reset 命令的所有秘密, 那些曾经无规律可循的命令现在变得十分规律, 而造成曾经那种情况的原因一方面是由于大多数人对于 Git 底层原理不了解所导致的, 另一方面是因为使用命令的缩写; 而下面的 checkout 指令也大体是这样的情况

## checkout 命令

>  在官方手册中对于 checkout 命令的解释是**切换分支或恢复工作区文件**, 与 reset 命令作用于**本地仓库**层面不同, checkout 作用于**工作区**; 同时由于历史原因 checkout 肩负了两个使命, 这也导致了在使用 checkout 时确实不像使用 reset 那样浑然一体, 官方也注意到这个问题, 因此在新版本 Git 中将两个功能分开, 推荐使用新命令 restore 来恢复工作区文件, switch 来切换分支
>
> 目前这两个命令还是一个**实验性机制**, 虽然现在仍说之后的行为可能发生改变, 但我认为改变现有功能的概率很低, 因此可以使用新指令还是使用新指令为好

本文旨在探究 Git 底层原理的撤销机制, 因此仍使用 checkout 指令做分析, 相应的 restore 指令作为补充给出; 同时此处只探究 checkout 撤销修改的功能, 而不探究切换分支的功能

`git checkout` 命令的完整形式

```
git checkout [options] <tree-ish> <pathspec>
```

与 reset 命令相似, checkout 命令的完整形式也有几部分构成:

- 选项 (options): 指定 checkout 输入输出或获取参数的部分, 相当于配置 checkout 以获得不同的表现
- **树对象 (tree-ish)**: 依据的**树对象**, 大部分时候此处都是一个 **commit对象** , 而之所以该参数不是 `commit` 的原因是因为默认情况下, 该处是指**暂存区抽象出的树对象**, 也即在不给出此参数时, 默认从**暂存区**恢复数据
- **重置路径 (pathspec)**: 指定 checkout 命令需要撤销修改的具体文件路径, 默认为**无**即**无文件需撤销 (与 reset 不同)**, 若指定发生的魔法和 reset 的一样

接下来同样会给出常用的命令和完整形式并解释

**例**:

1. 撤销工作区修改 | 撤销工作区部分文件修改

   ```
   指令: git checkout {. | files}
   完整指令: 同上
   
   新指令: git restore {. | files}
   ```

   **checkout 命令无法指定 `tree-ish` 为暂存区, 因此只需留空使用默认即可**

   如想重置工作区所有文件, 则需将 `pathspec` 参数设为 `.`

2. 回退工作区和暂存区至某次提交

   ````
   指令: git checkout <commit> { . |  files}
   
   新指令: git restore --staged --worktree --source <commit> {. | files}
   简化: git restore -S -W [-s <commit>] {. | files}
   ````

3. 撤销暂存区修改

   ```
   新指令: git restore -S [-s <commit>] {. | files}
   ```
   
   **旧命令中 checkout 无法做到, 应使用 reset 做, 但新命令 restore 可以**

本质上来说, checkout 通过移动 **HEAD** 指针的指向并将新**HEAD**指向的文件快照同步到工作区和暂存区, 所以在不指定 `commit` 时便默认使用**暂存区**数据为依据, 而如果**暂存区**与**本地仓库**相同则**HEAD**不动, 如果不同则必然**暂存区**的数据更新, 而**HEAD**无法向前移动, 所以**无论暂存区有无新暂存数据, 本地仓库的HEAD指针都不会移动**,  此时如果指定 `pathspec` 参数, 便只具有撤销工作区修改的效果; 
而在指定 `commit` , 却未指定 `pathspec` 参数时, 便会出现一种特殊情况, Git 称之为 **'detached HEAD' state (分离头指针状态)**, 而这种机制可以说是为了 checkout 的另一个功能**切换分支**做基础, 但从最终效果层面确实难以理解, 因此新指令 restore 将这种效果取消, 必须给出 `pathspec` 参数, 此时的**本地仓库的HEAD指针会指向指定的 commit, **

[^1]: 本质上只有**本地仓库**层面有分支指针,  reset 命令只在**本地仓库**层面移动了分支指针, 选定不同模式后通过在**暂存区或工作区**同步移动后的分支指针指向的提交对象来实现重置的效果, 但也可将**本地仓库, 暂存区和工作区**抽象成**三棵树**, 每个层面有个**分支指针**来表示当前该层面的文件情况 (仓库层面使用指针来表示文件情况, 其余两个层面分别用**快照索引**和**文件本身情况**来表示), 所以 reset 命令才可指定重置范围
